<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Dock Client Tutorial</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="concepts.html"><strong aria-hidden="true">2.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts_rdf.html"><strong aria-hidden="true">2.1.</strong> RDF/json-ld</a></li><li class="chapter-item expanded "><a href="concepts_vcdm.html"><strong aria-hidden="true">2.2.</strong> VCDM/VP</a></li><li class="chapter-item expanded "><a href="concepts_did.html"><strong aria-hidden="true">2.3.</strong> DID</a></li></ol></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">3.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial_did.html"><strong aria-hidden="true">3.1.</strong> DID</a></li><li class="chapter-item expanded "><a href="tutorial_resolver.html"><strong aria-hidden="true">3.2.</strong> Resolver</a></li><li class="chapter-item expanded "><a href="tutorial_ipv.html"><strong aria-hidden="true">3.3.</strong> Issuance, Presentation, Verification</a></li><li class="chapter-item expanded "><a href="tutorial_revocation.html"><strong aria-hidden="true">3.4.</strong> Revocation</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Dock Client Tutorial</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<h1><a class="header" href="#concepts" id="concepts">Concepts</a></h1>
<ol>
<li><a href="./concepts_did.html">DID</a></li>
<li><a href="./concepts_vcdm.html">Verifiable credentials</a></li>
</ol>
<h1><a class="header" href="#verifiable-credentials" id="verifiable-credentials">Verifiable Credentials</a></h1>
<p>Credentials are a part of our daily lives: driver's licenses are used to assert that we are capable of operating a motor vehicle, university degrees can be used to assert our level of education, and government-issued passports enable us to travel between countries. These credentials provide benefits to us when used in the physical world, but their use on the Web continues to be elusive.</p>
<p>Currently it is difficult to express education qualifications, healthcare data, financial account details, and other sorts of third-party verified machine-readable personal information on the Web. The difficulty of expressing digital credentials on the Web makes it challenging to receive the same benefits through the Web that physical credentials provide us in the physical world.</p>
<p>The <a href="https://www.w3.org/TR/vc-data-model/">Verifiable Credentials Data Model 1.0 (VCDM)</a> specification provides a standard way to express credentials on the Web in a way that is cryptographically secure, privacy respecting, and machine-verifiable.</p>
<h2><a class="header" href="#participants-and-workflow" id="participants-and-workflow">Participants and workflow</a></h2>
<ul>
<li>Credentials are issued by an entity called the <strong>issuer</strong>.</li>
<li><strong>Issuer</strong> issues the credential about a <strong>subject</strong> by signing the credential with his key. If the credential is revocable,
the issuer must specify how and from where revocation status must be checked. It is not necessary that revocation is managed by
the issuer, the issuer might designate a different authority for revocation.</li>
<li><strong>Issuer</strong> gives the credential to the <strong>holder</strong>. The <strong>holder</strong> might be the same as the <strong>subject</strong>.</li>
<li>A service provider or anyone willing to check if the <strong>holder</strong> possesses certain credentials requests a <strong>presentation</strong> about those
credentials. This entity requesting the <strong>presentation</strong> is called the <strong>verifier</strong>. To protect against replay attacks, (a
verifier receiving the presentation and replaying the same presentation at some other verifier), a verifier must supply a
challenge that must be embedded in the presentation.</li>
<li><strong>Holder</strong> creates a <strong>presentation</strong> for the required credentials. The <strong>presentation</strong> must indicate which
credentials it is about and must be signed by the <strong>holder</strong> of the credentials.</li>
<li><strong>Verifier</strong> on receiving the presentation verifies the validity of each credential in the <strong>presentation</strong>. This includes
checking correctness of the data model of the credential, the authenticity by verifying the issuer's signature and revocation
status if the credential is revocable. It then checks whether the presentation contains the signature from the
<strong>holder</strong> on the presentation which also includes his given challenge.</li>
</ul>
<h2><a class="header" href="#issuing" id="issuing">Issuing</a></h2>
<p>To issue a verifiable credential, the issuer needs to have a public key that is accessible by the holder and verifier to verify the
signature (in <code>proof</code>) in the credential. Though the VCDM spec does not mandate it, an issuer in Dock must have a DID on chain.
This DID is present in the credential in the <code>issuer</code> field.</p>
<h2><a class="header" href="#revocation" id="revocation">Revocation</a></h2>
<p>If the credential is revocable, the issuer must specify how the revocation check must be done in the <code>credentialStatus</code> field.
On Dock, credential revocation is managed with a revocation registry. There can be multiple registries on chain and each
registry has a unique id. It is advised that the revocation authority creates a new registry for each credential type.
While issuing the credential, issuer embeds the revocation registry's id in the credential in the <code>credentialStatus</code> field.
To revoke a credential, the revocation authority (might be same as the issuer), puts a hash of the credential id in the revocation registry.
To check the revocation status of a credential, hash the credential id and query the registry id specified in the credential.</p>
<p>The revocation of a credential can be undone if the revocation registry supports undoing. Moreover, currently, each registry is
controlled by a single DID so that DID can revoke a credential or undo the revocation. In future, Dock will support controlling
the registry with mulitple DIDs and in different fashions, like any one of the controller DIDs could revoke or a threshold is needed,
etc. To learn more about revocation registries, refer the corresponding section of the documentation.</p>
<h2><a class="header" href="#presentation" id="presentation">Presentation</a></h2>
<p>The holder while creating the presentation signs it with his private key. For the verifier to verify this signature, he
must know the holder's public key. One way to achieve this is to make the holder have a DID too so that the verifier can look
up the DID on chain and learn the public key.</p>
<h1><a class="header" href="#w3c-did" id="w3c-did">W3C DID</a></h1>
<p>DID stands for Decentralized IDentifiers. DIDs are meant to be globally unique identifiers that allow their owner to
prove cryptographic control over them. The owner(s) of the DID is called the <code>controller</code>. The identifiers are not just assignable
to humans but to anything. Quoting the <a href="https://www.w3.org/TR/did-core/">DID spec</a>,</p>
<blockquote>
<p>A DID identifies any subject (e.g., a person, organization, thing, data model, abstract entity, etc.) that the controller
of the DID decides that it identifies.</p>
</blockquote>
<p>DIDs differ from public keys in that DIDs are persistent, i.e. a public key has to be changed if the private key is stolen/lost
or the cryptographic scheme of the public key is no longer considered safe. This is not the case with DIDs, they can remain
unchanged even when the associated cryptographic material changes. Moreover, a DID can have multiple keys and any of its
keys can be rotated. Additionally, depending on the scheme, public keys can be quite large (several hundred bytes in RSA)
whereas a unique identifier can be much smaller.</p>
<p>Each DID is associated with a <code>DID Document</code> that specifies the subject, the public keys, the authentication mechanisms usable
by the subject, authorizations the subject has given to others, service endpoints to communicate with the subject, etc,
for all properties that can be put in the DID Document, refer <a href="https://www.w3.org/TR/did-core/#core-properties">this section of the spec</a>.
DIDs and their associated DID Documents are stored on the DID registry which is a term used for the centralized on decentralized
database persisting the DID and its Document.</p>
<p>The process of discovering the DID Document for a DID is called DID resolution and the tool (library or a service) is called DID
resolver. To resolve the DID, the resolver first needs to check on which registry the DID is hosted and then decide whether it
is capable or willing to lookup that registry. The registry is indicated by the <code>DID method</code> of that DID. In addition to the
registry, the method also specifies other details of that DID like the supported operations, crypto, etc. Each DID method
defines its own specification, Docks's DID method spec is <a href="https://github.com/docknetwork/dock-did-driver">here</a>. In case of
Dock, the registry is the Dock blockchain and the method is <code>dock</code>.</p>
<p>An example Dock DID.</p>
<pre><code>did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW
</code></pre>
<p>Above DID has method <code>dock</code> and the DID identifier is <code>5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW</code>. Dock DID identifiers
are 32 bytes in size.</p>
<p>An example DID Document</p>
<pre><code>{
  &quot;@context&quot;: &quot;https://www.w3.org/ns/did/v1&quot;,
  &quot;id&quot;: &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW&quot;,
  &quot;authentication&quot;: [
    &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW#keys-1&quot;
  ],
  &quot;assertionMethod&quot;: [
    &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW#keys-1&quot;
  ],
  &quot;publicKey&quot;: [
    {
      &quot;id&quot;: &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW#keys-1&quot;,
      &quot;type&quot;: &quot;Sr25519VerificationKey2020&quot;,
      &quot;controller&quot;: &quot;did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW&quot;,
      &quot;publicKeyBase58&quot;: &quot;8bEsU4JWBVVFQCdd8du7Txo6L3JHdJYQByHBqzL1WXwy&quot;
    }
  ]
}
</code></pre>
<p>Note that Dock DIDs support only one key as of now. The key is present in the <code>publicKey</code> section. Note how that public key
is referred to using its <code>id</code> in <code>authentication</code> and <code>assertionMethod</code> sections. The above document states that the DID
<code>did:dock:5CEdyZkZnALDdCAp7crTRiaCq6KViprTM6kHUQCD8X6VqGPW</code> authenticates with public key under <code>publicKey</code> and also when
it attests to some fact (becomes issuer), it uses that key. As there is only one public key supported for a DID, that
public key is used for both <code>authentication</code> and <code>assertionMethod</code>. When support for multiple keys is added, the DID can
specify which key(s) needs to be used for <code>authentication</code> and which ones for <code>assertionMethod</code>.</p>
<p>Another thing to keep in mind is that the keys associated with the Dock DID are independent of the keys used to send the
transaction on chain and pay fees. Eg. Alice might not have any tokens to write anything on chain but can still create a
DID and corresponding key and ask Bob who has tokens to register the DID on chain. Even though Bob wrote the DID on chain,
he cannot update or remove it since only Alice has the keys associated with that DID. Similarly, when Alice wants to update
the DID (public key or controller), it can create the update, sign it and send it to Carol this time to send the update on
chain.</p>
<h1><a class="header" href="#tutorial" id="tutorial">Tutorial</a></h1>
<ol>
<li><a href="./tutorial_did.html">DID</a></li>
<li><a href="./tutorial_revocation.html">Revocation</a></li>
<li><a href="./tutorial_ipv.html">Verifiable credentials</a></li>
</ol>
<h1><a class="header" href="#did" id="did">DID</a></h1>
<p>If you are not familiar with DIDs, you can get a conceptual overview <a href="./concepts_did.html">here</a>.</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>DIDs in Dock are created by choosing a 32 byte unique (on Dock chain) identifier along with a public key. The public key
can be changed by providing a signature with the currently active key. The DID can also be removed by providing a signature
with the currently active key. As of now, a DID can have only one key at a time.
The chain-state stores a few things for a DID, the current public key, the controller and the block number when the DID was
last updated, so in the beginning the block number would be the one where the DID was created, when a DID's key is updated,
that block number is changed to the one in which the key got updated. This is done for replay protection as every
update (or removal) to the DID must include the last block number where the DID was updated and after each update the block
number changes, thus giving replay protection. This detail however is hidden in the API so the caller should not have to worry
about this.</p>
<h2><a class="header" href="#did-creation" id="did-creation">DID creation</a></h2>
<p>Create a new random DID.</p>
<pre><code class="language-js">import {createNewDockDID} from '@dock/sdk/utils/did';

const did = createNewDockDID();
</code></pre>
<p>The DID is not yet registered on the chain. Before the DID can be registered, a public key needs to created as well.</p>
<h2><a class="header" href="#public-key-creation" id="public-key-creation">Public key creation</a></h2>
<p>Dock supports 3 kinds of public keys, Sr25519, Ed25519 and EcdsaSecp256k1. These public keys are supported
through 3 classes, <code>PublicKeySr25519</code>, <code>PublicKeyEd25519</code> and <code>PublicKeySecp256k1</code> respectively. These 3 classes
extend from the same class called <code>PublicKey</code>. These can be instantiated directly by passing them as hex encoded bytes</p>
<pre><code class="language-js">import {PublicKeySr25519, PublicKeyEd25519, PublicKeySecp256k1} from '@dock/sdk/api';

const pk1 = new PublicKeySr25519(bytesAsHex);
const pk2 = new PublicKeyEd25519(bytesAsHex);
const pk3 = new PublicKeySecp256k1(bytesAsHex);
</code></pre>
<p>Or they can be created by first creating a keyring</p>
<pre><code class="language-js">import {PublicKeySr25519, PublicKeyEd25519, PublicKeySecp256k1} from '@dock/sdk/api';

// Assuming you had a keyring, you can create keypairs or used already created keypairs
const pair1 = keyring.addFromUri(secretUri, someMetadata, 'ed25519');
const pk1 = PublicKeyEd25519.fromKeyringPair(pair1);

const pair2 = keyring.addFromUri(secretUri2, someMetadata, 'sr25519');
const pk2 = PublicKeySr25519.fromKeyringPair(pair2);

</code></pre>
<p>Polkadot-js keyring does not support ECDSA with secp256k1 so there is a function <code>generateEcdsaSecp256k1Keypair</code> that
takes some entropy and generate a keypair.</p>
<pre><code class="language-js">import { generateEcdsaSecp256k1Keypair } from '@dock/sdk/utils/misc';
// The pers and entropy are optional but must be used when keys need to be deterministic
const pair3 = generateEcdsaSecp256k1Keypair(pers, entropy);
const pk3 = PublicKeySecp256k1.fromKeyringPair(pair3);
</code></pre>
<p>Or you can directly pass any of the above keypairs in the function <code>getPublicKeyFromKeyringPair</code> and it will return an
object of the proper child class of <code>PublicKey</code></p>
<pre><code class="language-js">import { getPublicKeyFromKeyringPair } from '@dock/sdk/utils/misc';
const publicKey = getPublicKeyFromKeyringPair(pair);
</code></pre>
<h2><a class="header" href="#registering-a-new-did-on-chain" id="registering-a-new-did-on-chain">Registering a new DID on chain</a></h2>
<p>Now that you have a DID and a public key, the DID can be registered on the Dock chain. Note that this public key associated
with DID is independent of the key used for sending the transaction and paying the fees.</p>
<ol>
<li>First create a key detail object. The first argument of this function is a <code>PublicKey</code> and the second argument is
the controller. The controller is the DID that controls the public key and this can be the same as the DID being
registered.
<pre><code class="language-js">import {createKeyDetail} from '@dock/sdk/utils/did';
const keyDetail = createKeyDetail(publicKey, did);
</code></pre>
</li>
<li>Now submit the transaction using a <code>DockAPI</code> object and the newly created DID <code>did</code> and <code>keyDetail</code>.
<pre><code class="language-js">const transaction = dock.did.new(did, keyDetail);
// Send the transaction to the chain
await dock.sendTransaction(transaction);
</code></pre>
</li>
</ol>
<h2><a class="header" href="#fetching-a-did-from-chain" id="fetching-a-did-from-chain">Fetching a DID from chain</a></h2>
<p>To get a DID document, use <code>getDocument</code>
<code>js const result = await dock.did.getDocument(did); </code>
To get more</p>
<h2><a class="header" href="#updating-an-existing-did-on-chain" id="updating-an-existing-did-on-chain">Updating an existing DID on chain</a></h2>
<p>The public key or the controller of an on-chain DID can be updated by preparing a signed key update.</p>
<ol>
<li>Create a new public key and fetch the current keypair to sign the key update message
<pre><code class="language-js">// the current pair, its a sr25519 in this example
const currentPair = dock.keyring.addFromUri(secretUri, null, 'sr25519');
const newPk = // Using any of the above methods
</code></pre>
</li>
<li>The caller might directly create a signed key update
<pre><code class="language-js">import {createSignedKeyUpdate} from '@dock/sdk/utils/did';
// If you do not wish to update the controller, don't pass `newController`
const [keyUpdate, signature] = await createSignedKeyUpdate(dock.did, did, newPk, currentPair, newController);
</code></pre>
</li>
<li>In some cases the caller might not have the keypair like a hardware wallet or a remote signer, in that case, the caller
creates the key update message bytes with <code>createKeyUpdate</code> to pass to the signer and get the signature
<pre><code class="language-js">import {createKeyUpdate} from '@dock/sdk/utils/did';
const keyUpdate = await createKeyUpdate(dock.did, did, newPk, newController);
const signature = // Get the signature on `keyUpdate`
</code></pre>
</li>
<li>Now send the key update message with the signature to the chain in a transaction
<pre><code class="language-js">const transaction = dock.did.updateKey(keyUpdate, signature);
await dock.sendTransaction(transaction);
</code></pre>
</li>
</ol>
<h2><a class="header" href="#updating-an-existing-did-on-chain-1" id="updating-an-existing-did-on-chain-1">Updating an existing DID on chain</a></h2>
<p>A DID can be removing from the chain by sending the corresponding message signed with the current key.</p>
<ol>
<li>Fetch the current keypair to sign the DID removal message
<pre><code class="language-js">// the current pair, its a sr25519 in this example
const currentPair = dock.keyring.addFromUri(secretUri, null, 'sr25519');
</code></pre>
</li>
<li>The caller might directly create a signed message
<pre><code class="language-js">import {createSignedDidRemoval} from '@dock/sdk/utils/did';
const [didRemoval, signature] = await createSignedDidRemoval(dock.did, dockDID, currentPair);
</code></pre>
</li>
<li>As mentioned above, in some cases the caller might not have the keypair, then he creates the removal message bytes
with <code>createKeyUpdate</code> to pass to the signer and get the signature
<pre><code class="language-js">import {createDidRemoval} from '@dock/sdk/utils/did';
const didRemoval = await createDidRemoval(dock.did, did);
const signature = // Get the signature on `didRemoval`
</code></pre>
</li>
<li>Now send the message with the signature to the chain in a transaction
<pre><code class="language-js">const transaction = dock.did.remove(didRemoval, signature);
await dock.sendTransaction(transaction);
</code></pre>
</li>
</ol>
<p>Note that they accounts used to send the transactions are independent of the keys associated with the DID. So the DID could
have been created with one account, updated with another account and removed with another account. The accounts are not relevant
in the data model and not associated with the DID in the chain-state.</p>
<h1><a class="header" href="#did-resolver" id="did-resolver">DID resolver</a></h1>
<p>The process of learning the DID Document of a DID is called DID resolution and tool that does the resolution is called the
resolver. Resolution involves looking at the DID method and then fetching the DID Document from the registry, the registry
might be a centralized database or a blockchain. The SDK supports resolving Dock DIDs natively.
For other DIDs, resolving the DID through the <a href="https://uniresolver.io">Universal Resolver</a> is supported.</p>
<p>Each resolver should extend the class <code>DIDResolver</code> and implement the <code>resolve</code> method that accepts a DID and returns the
DID document. There is another class called <code>MultiResolver</code> that can accept several types of resolvers (objects of subclasses
of <code>DIDResolver</code>) and once the <code>MultiResolver</code> is initialized with the resolvers of different DID methods, it can resolve
DIDs of those methods.</p>
<h2><a class="header" href="#dock-resolver" id="dock-resolver">Dock resolver</a></h2>
<p>The resolver for Dock DIDs <code>DockResolver</code> connects to the Dock blockchain to get the DID details. The resolver is
constructed by passing it a Dock API object so that it can connect to a Dock node. This is how you resolve a Dock DID:</p>
<pre><code class="language-js">import { DockResolver } from '@dock/sdk/resolver';

// Assuming the presence of Dock API object `dock`
const dockResolver = new DockResolver(dock);
// Say you had a DID `dock:did:5D.....`
const didDocument = dockResolver.resolve('dock:did:5D.....');
</code></pre>
<h2><a class="header" href="#creating-a-resolver-class-for-a-different-method" id="creating-a-resolver-class-for-a-different-method">Creating a resolver class for a different method</a></h2>
<p>If you want to resolve DIDs other than Dock and do not have/want access to the universal resolver, you can extend the
<code>DIDResolver</code> class to create a custom resolver. Following is an example to build a custom Ethereum resolver. It uses the
library <a href="https://github.com/decentralized-identity/ethr-did-resolver">ethr-did-resolver</a> and accepts a provider information
as configuration. The example below uses Infura to get access to an Ethereum node and read the DID off Ethereum.</p>
<pre><code class="language-js">import { DIDResolver } from '@dock/sdk/resolver';
import ethr from 'ethr-did-resolver';

// Infura's Ethereum provider for the main net.
const ethereumProviderConfig = {
  networks: [
    {
      name: 'mainnet',
      rpcUrl: 'https://mainnet.infura.io/v3/blahblahtoken',
    },
  ],
};

// Custom ethereum resolver class
class EtherResolver extends DIDResolver {
  constructor(config) {
    super();
    this.ethres = ethr.getResolver(config).ethr;
  }

  async resolve(did) {
    const parsed = this.parseDid(did);
    try {
      return await this.ethres(did, parsed);
    } catch (e) {
      throw new NoDIDError(did);
    }
  }
}

// Construct the resolver
const ethResolver = new EtherResolver(ethereumProviderConfig);

// Say you had a DID `did:ethr:0x6f....`
const didDocument = ethResolver.resolve('did:ethr:0x6f....');
</code></pre>
<h2><a class="header" href="#universal-resolver" id="universal-resolver">Universal resolver</a></h2>
<p>To resolve DIDs using the <a href="https://uniresolver.io">Universal Resolver</a>, use the <code>UniversalResolver</code>. It needs the URL
of the universal resolver and assumes the universal resolver from this <a href="https://github.com/decentralized-identity/universal-resolver">codebase</a>
is running at the URL.</p>
<pre><code class="language-js">import { UniversalResolver } from '@dock/sdk/resolver';

// Change the resolver URL to something else in case you cannot use the resolver at https://uniresolver.io
const universalResolverUrl = 'https://uniresolver.io';
const universalResolver = new UniversalResolver(universalResolverUrl);

// Say you had a DID `did:btcr:xk....`
const didDocument = universalResolver.resolve('did:btcr:xk....');
</code></pre>
<h2><a class="header" href="#resolving-dids-of-several-did-methods-with-a-single-resolver" id="resolving-dids-of-several-did-methods-with-a-single-resolver">Resolving DIDs of several DID methods with a single resolver</a></h2>
<p>In case you need to resolve DIDs from more than one method, a <code>MultiResolver</code> object can be created by passing
resolvers of various DID methods. The <code>MultiResolver</code> also accepts a <code>UniversalResolver</code> as an optional parameter which
is used when a DID for an unknown method needs to be resolved. The <code>resolvers</code> object below has resolvers for DID methods
<code>dock</code> and <code>ethr</code>. For resolving DID of any other method, the given <code>UniversalResolver</code> object will be used.</p>
<pre><code class="language-js">import { MultiResolver } from '@dock/sdk/resolver';


const resolvers = {
    dock: new DockResolver(dock), // Prebuilt resolver
    ethr: new EtherResolver(ethereumProviderConfig), // Custom resolver
  };

const multiResolver = new MultiResolver(resolvers, new UniversalResolver(universalResolverUrl));

// Say you had a DID `did:dock:5D....`, then the `DockResolver` will be used as there a resolver for Dock DID.
const didDocumentDock = multiResolver.resolve('did:dock:5D....');

// Say you had a DID `did:btcr:xk....`, then the `UniversalResolver` will be used as there is no resolver for BTC DID.
const didDocumentBtc = multiResolver.resolve('did:btcr:xk....');
</code></pre>
<h1><a class="header" href="#verifiable-credentials-and-verifiable-presentations-issuing-signing-and-verification" id="verifiable-credentials-and-verifiable-presentations-issuing-signing-and-verification">Verifiable Credentials and Verifiable Presentations: issuing, signing and verification</a></h1>
<h2><a class="header" href="#table-of-contents" id="table-of-contents">Table of contents</a></h2>
<ul>
<li><a href="tutorial_ipv.html#incremental-creation-and-verification-of-verifiable-credentials">Incremental creation and verification of VC</a>
<ul>
<li><a href="tutorial_ipv.html#building-a-verifiable-credential">Building a Verifiable Credential</a>
<ul>
<li><a href="tutorial_ipv.html#adding-a-context">Adding a Context</a></li>
<li><a href="tutorial_ipv.html#adding-a-type">Adding a Type</a></li>
<li><a href="tutorial_ipv.html#adding-a-subject">Adding a Subject</a></li>
<li><a href="tutorial_ipv.html#setting-a-status">Setting a Status</a></li>
<li><a href="tutorial_ipv.html#setting-the-issuance-date">Setting the Issuance Date</a></li>
<li><a href="tutorial_ipv.html#setting-an-expiration-date">Setting an Expiration Date</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#signing-a-verifiable-credential">Signing a Verifiable Credential</a></li>
<li><a href="tutorial_ipv.html#verifying-a-verifiable-credential">Verifying a Verifiable Credential</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#incremental-creation-and-verification-of-verifiable-presentations">Incremental creation and verification of VP</a>
<ul>
<li><a href="tutorial_ipv.html#building-a-verifiable-presentation">Building a Verifiable Presentation</a>
<ul>
<li><a href="tutorial_ipv.html#adding-a-context">Adding a Context</a></li>
<li><a href="tutorial_ipv.html#adding-a-type">Adding a Type</a></li>
<li><a href="tutorial_ipv.html#setting-a-holder">Setting a Holder</a></li>
<li><a href="tutorial_ipv.html#adding-a-verifiable-credential">Adding a Verifiable Credential</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#signing-a-verifiable-presentation">Signing a Verifiable Presentation</a></li>
<li><a href="tutorial_ipv.html#verifying-a-verifiable-presentation">Verifying a Verifiable Presentation</a></li>
</ul>
</li>
<li><a href="tutorial_ipv.html#using-dids">Using DIDs</a></li>
<li><a href="tutorial_ipv.html#creating-a-keydoc">Creating a keyDoc</a></li>
</ul>
<hr />
<h2><a class="header" href="#incremental-creation-and-verification-of-verifiable-credentials" id="incremental-creation-and-verification-of-verifiable-credentials">Incremental creation and verification of Verifiable Credentials</a></h2>
<p>The <code>client-sdk</code> exposes a <code>VerifiableCredential</code> class that is useful to incrementally create valid Verifiable Credentials of any type, sign them and verify them.
Once the credential is initialized, you can sequentially call the different methods provided by the class to add contexts, types, issuance dates and everything else.</p>
<h3><a class="header" href="#building-a-verifiable-credential" id="building-a-verifiable-credential">Building a Verifiable Credential</a></h3>
<p>The first step to build a Verifiable Credential is to initialize it, we can do that using the <code>VerifiableCredential</code> class constructor which takes a <code>credentialId</code> as sole argument:</p>
<pre><code class="language-javascript">let vc = new VerifiableCredential('http://example.edu/credentials/2803');
</code></pre>
<p>You now have an unsigned Verifiable Credential in the <code>vc</code> variable!
This Credential isn't signed since we only just initialized it. It brings however some useful defaults to make your life easier.</p>
<pre><code class="language-javascript">&gt;    vc.context
&lt;-   [&quot;https://www.w3.org/2018/credentials/v1&quot;]
&gt;    vc.issuanceDate
&lt;-   &quot;2020-04-14T14:48:48.486Z&quot;
&gt;    vc.type
&lt;-   [&quot;VerifiableCredential&quot;]
&gt;    vc.subject
&lt;-   []
</code></pre>
<p>The default <code>context</code> is an array with <code>&quot;https://www.w3.org/2018/credentials/v1&quot;</code> as first element. This is required by the VCDMv1 specs so having it as default helps ensure your Verifiable Credentials will be valid in the end.
A similar approach was taken on the <code>type</code> property, where the default is an array with <code>&quot;VerifiableCredential&quot;</code> already populated. This is also required by the specs.
The <code>subject</code> property is required to exist, so this is already initialized for you as well although it is empty for now.
Finally the <code>issuanceDate</code> is also set to the moment you initialized the <code>VerifiableCredential</code> object. You can change this later if desired but it helps having it in the right format from the get go.</p>
<p>We could also have checked those defaults more easily by checking the Verifiable Credential's JSON representation.
This can be achieved by calling the <code>toJSON()</code> method on it:</p>
<pre><code class="language-javascript">&gt;    vc.toJSON()
&lt;-   {
       &quot;@context&quot;: [ &quot;https://www.w3.org/2018/credentials/v1&quot; ],
       &quot;credentialSubject&quot;: [],
       &quot;id&quot;: &quot;http://example.edu/credentials/2803&quot;,
       &quot;type&quot;: [
         &quot;VerifiableCredential&quot;
       ],
       &quot;issuanceDate&quot;: &quot;2020-04-14T14:48:48.486Z&quot;
     }
</code></pre>
<p>An interesting thing to note here is the transformation happening to some of the root level keys in the JSON representation of a <code>VerifiableCredential</code> object. For example <code>context</code> gets transformed into <code>@context</code> and <code>subject</code> into <code>credentialSubject</code>. This is to ensure compliance with the Verifiable Credential Data Model specs while at the same time providing you with a clean interface to the <code>VerifiableCredential</code> class in your code.</p>
<p>Once your Verifiable Credential has been initialized, you can proceed to use the rest of the building functions to define it completely before finally signing it.</p>
<h4><a class="header" href="#adding-a-context" id="adding-a-context">Adding a Context</a></h4>
<p>A context can be added with the <code>addContext</code> method. It accepts a single argument <code>context</code> which can either be a string (in which case it needs to be a valid URI), or an object (in which case it needs to be a valid context object with a <code>@context</code> field):</p>
<pre><code class="language-javascript">&gt;   vc.addContext('https://www.w3.org/2018/credentials/examples/v1')
&gt;   vc.context
&lt;-  [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ])
</code></pre>
<h4><a class="header" href="#adding-a-type" id="adding-a-type">Adding a Type</a></h4>
<p>A type can be added with the <code>addType</code> function. It accepts a single argument <code>type</code> that needs to be a string:</p>
<pre><code class="language-javascript">&gt;   vc.addType('AlumniCredential')
&gt;   vc.type
&lt;-  [
      'VerifiableCredential',
      'AlumniCredential'
    ]
</code></pre>
<h4><a class="header" href="#adding-a-subject" id="adding-a-subject">Adding a Subject</a></h4>
<p>A subject can be added with the <code>addSubject</code> function. It accepts a single argument <code>subject</code> that needs to be an object with an <code>id</code> property:</p>
<pre><code class="language-javascript">&gt;   vc.addSubject({ id: 'did:dock:123qwe123qwe123qwe', alumniOf: 'Example University' })
&gt;   vc.subject
&lt;-  {id: 'did:dock:123qwe123qwe123qwe', alumniOf: 'Example University'}
</code></pre>
<h4><a class="header" href="#setting-a-status" id="setting-a-status">Setting a Status</a></h4>
<p>A status can be set with the <code>setStatus</code> function. It accepts a single argument <code>status</code> that needs to be an object with an <code>id</code> property:</p>
<pre><code class="language-javascript">&gt;   vc.setStatus({ id: &quot;https://example.edu/status/24&quot;, type: &quot;CredentialStatusList2017&quot; })
&gt;   vc.status
&lt;-  {
        &quot;id&quot;: &quot;https://example.edu/status/24&quot;,
        &quot;type&quot;: &quot;CredentialStatusList2017&quot;
    }
</code></pre>
<h4><a class="header" href="#setting-the-issuance-date" id="setting-the-issuance-date">Setting the Issuance Date</a></h4>
<p>The issuance date is set by default to the datetime you first initialize your <code>VerifiableCredential</code> object. This means that you don't necessarily need to call this method to achieve a valid Verifiable Credential (which are required to have an issuanceDate property).
However, if you need to change this date you can use the <code>setIssuanceDate</code> method. It takes a single argument <code>issuanceDate</code> that needs to be a string with a valid ISO formatted datetime:</p>
<pre><code class="language-javascript">&gt;   vc.issuanceDate
&lt;-  &quot;2020-04-14T14:48:48.486Z&quot;
&gt;   vc.setIssuanceDate(&quot;2019-01-01T14:48:48.486Z&quot;)
&gt;   vc.issuanceDate
&lt;-  &quot;2019-01-01T14:48:48.486Z&quot;
</code></pre>
<h4><a class="header" href="#setting-an-expiration-date" id="setting-an-expiration-date">Setting an Expiration Date</a></h4>
<p>An expiration date is not set by default as it isn't required by the specs. If you wish to set one, you can use the <code>setExpirationDate</code> method. It takes a single argument <code>expirationDate</code> that needs to be a string with a valid ISO formatted datetime:</p>
<pre><code class="language-javascript">&gt;   vc.setExpirationDate(&quot;2029-01-01T14:48:48.486Z&quot;)
&gt;   vc.expirationDate
&lt;-  &quot;2029-01-01T14:48:48.486Z&quot;
</code></pre>
<h3><a class="header" href="#signing-a-verifiable-credential" id="signing-a-verifiable-credential">Signing a Verifiable Credential</a></h3>
<p>Once you've crafted your Verifiable Credential it is time to sign it. This can be achieved with the <code>sign</code> method. It requires a <code>keyDoc</code> parameter (an object with the params and keys you'll use for signing) and it also accepts a boolean <code>compactProof</code> that determines whether you want to compact the JSON-LD or not:</p>
<pre><code class="language-javascript">&gt;   await vc.sign(keyDoc)
</code></pre>
<p>Please note that signing is an async process.
Once done, your <code>vc</code> object will have a new <code>proof</code> field:</p>
<pre><code class="language-javascript">&gt;   vc.proof
&lt;-  {
        type: &quot;EcdsaSecp256k1Signature2019&quot;,
        created: &quot;2020-04-14T14:48:48.486Z&quot;,
        jws: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEQCIAS8ZNVYIni3oShb0TFz4SMAybJcz3HkQPaTdz9OSszoAiA01w9ZkS4Zx5HEZk45QzxbqOr8eRlgMdhgFsFs1FnyMQ&quot;,
        proofPurpose: &quot;assertionMethod&quot;,
        verificationMethod: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
    }
</code></pre>
<h3><a class="header" href="#verifying-a-verifiable-credential" id="verifying-a-verifiable-credential">Verifying a Verifiable Credential</a></h3>
<p>Once your Verifiable Credential has been signed you can proceed to verify it with the <code>verify</code> method. If you've used DIDs you need to pass a <code>resolver</code> for them. You can also use the booleans <code>compactProof</code> (to compact the JSON-LD) and <code>forceRevocationCheck</code> (to force revocation check). Please beware that setting <code>forceRevocationCheck</code> to false can allow false positives when verifying revocable credentials.
If your credential has uses the <code>status</code> field, you can pass a <code>revocationAPI</code> param that accepts an object describing the API to use for the revocation check. No params are required for the simplest cases:</p>
<pre><code class="language-javascript">&gt;   const result = await vc.verify()
&gt;   result
&lt;-  {
      verified: true,
      results: [
        {
          proof: [
            {
                '@context': 'https://w3id.org/security/v2',
                type: &quot;EcdsaSecp256k1Signature2019&quot;,
                created: &quot;2020-04-14T14:48:48.486Z&quot;,
                jws: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEQCIAS8ZNVYIni3oShb0TFz4SMAybJcz3HkQPaTdz9OSszoAiA01w9ZkS4Zx5HEZk45QzxbqOr8eRlgMdhgFsFs1FnyMQ&quot;,
                proofPurpose: &quot;assertionMethod&quot;,
                verificationMethod: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
            }
          ],
          verified: true
        }
      ]
    }
</code></pre>
<p>Please note that the verification is an async process that returns an object when the promise resolves. A boolean value for the entire verification process can be checked at the root level <code>verified</code> property.</p>
<hr />
<h2><a class="header" href="#incremental-creation-and-verification-of-verifiable-presentations" id="incremental-creation-and-verification-of-verifiable-presentations">Incremental creation and verification of Verifiable Presentations</a></h2>
<p>The <code>client-sdk</code> exposes a <code>VerifiablePresentation</code> class that is useful to incrementally create valid Verifiable Presentations of any type, sign them and verify them.
Once the presentation is initialized, you can sequentially call the different methods provided by the class to add <code>contexts</code>, <code>types</code>, <code>holders</code> and <code>credentials</code>.</p>
<h3><a class="header" href="#building-a-verifiable-presentation" id="building-a-verifiable-presentation">Building a Verifiable Presentation</a></h3>
<p>The first step to build a Verifiable Presentation is to initialize it, we can do that using the <code>VerifiablePresentation</code> class constructor which takes an <code>id</code> as sole argument:</p>
<pre><code class="language-javascript">let vp = new VerifiablePresentation('http://example.edu/credentials/1986');
</code></pre>
<p>You now have an unsigned Verifiable Presentation in the <code>vp</code> variable!
This Presentation isn't signed since we only just initialized it. It brings however some useful defaults to make your life easier.</p>
<pre><code class="language-javascript">&gt;    vp.context
&lt;-   [&quot;https://www.w3.org/2018/credentials/v1&quot;]
&gt;    vp.type
&lt;-   [&quot;VerifiablePresentation&quot;]
&gt;    vp.credentials
&lt;-   []
</code></pre>
<p>The default <code>context</code> is an array with <code>&quot;https://www.w3.org/2018/credentials/v1&quot;</code> as first element. This is required by the VCDMv1 specs so having it as default helps ensure your Verifiable Presentations will be valid in the end.
A similar approach was taken on the <code>type</code> property, where the default is an array with <code>&quot;VerifiablePresentation&quot;</code> already populated. This is also required by the specs.
The <code>credentials</code> property is required to exist, so this is already initialized for you as well although it is empty for now.</p>
<p>We could also have checked those defaults more easily by checking the Verifiable Presentation's JSON representation.
This can be achieved by calling the <code>toJSON()</code> method on it:</p>
<pre><code class="language-javascript">&gt;    vp.toJSON()
&lt;-   {
       &quot;@context&quot;: [ &quot;https://www.w3.org/2018/credentials/v1&quot; ],
       &quot;id&quot;: &quot;http://example.edu/credentials/1986&quot;,
       &quot;type&quot;: [
         &quot;VerifiablePresentation&quot;
       ],
       &quot;verifiableCredential&quot;: [],
     }
</code></pre>
<p>An interesting thing to note here is the transformation happening to some of the root level keys in the JSON representation of a <code>VerifiablePresentation</code> object. For example <code>context</code> gets transformed into <code>@context</code> and <code>credentials</code> into <code>verifiableCredential</code>. This is to ensure compliance with the Verifiable Credentials Data Model specs while at the same time providing you with a clean interface to the <code>VerifiablePresentation</code> class in your code.</p>
<p>Once your Verifiable Presentation has been initialized, you can proceed to use the rest of the building functions to define it completely before finally signing it.</p>
<h4><a class="header" href="#adding-a-context-1" id="adding-a-context-1">Adding a Context</a></h4>
<p>A context can be added with the <code>addContext</code> method. It accepts a single argument <code>context</code> which can either be a string (in which case it needs to be a valid URI), or an object (in which case it needs to be a valid context object with a <code>@context</code> field):</p>
<pre><code class="language-javascript">&gt;   vp.addContext('https://www.w3.org/2018/credentials/examples/v1')
&gt;   vp.context
&lt;-  [
      'https://www.w3.org/2018/credentials/v1',
      'https://www.w3.org/2018/credentials/examples/v1'
    ])
</code></pre>
<h4><a class="header" href="#adding-a-type-1" id="adding-a-type-1">Adding a Type</a></h4>
<p>A type can be added with the <code>addType</code> function. It accepts a single argument <code>type</code> that needs to be a string:</p>
<pre><code class="language-javascript">&gt;   vp.addType('CredentialManagerPresentation')
&gt;   vp.type
&lt;-  [
      'VerifiablePresentation',
      'CredentialManagerPresentation'
    ]
</code></pre>
<h4><a class="header" href="#setting-a-holder" id="setting-a-holder">Setting a Holder</a></h4>
<p>Setting a Holder is optional and it can be achieved using the <code>setHolder</code> method. It accepts a single argument <code>type</code> that needs to be a string (a URI for the entity that is generating the presentation):</p>
<pre><code class="language-javascript">&gt;   vp.setHolder('https://example.com/credentials/1234567890');
&gt;   vp.holder
&lt;-  'https://example.com/credentials/1234567890'
</code></pre>
<h4><a class="header" href="#adding-a-verifiable-credential" id="adding-a-verifiable-credential">Adding a Verifiable Credential</a></h4>
<p>Your Verifiable Presentations can contain one or more Verifiable Credentials inside.
Adding a Verifiable Credential can be achieved using the <code>addCredential</code> method. It accepts a single argument <code>credential</code> that needs to be an object (a valid, signed Verifiable Credential):</p>
<pre><code class="language-javascript">&gt;   vp.addCredential(vc);
&gt;   vp.credentials
&lt;-  [
      {...}
    ]
</code></pre>
<p>Please note that the example was truncated to enhance readability.</p>
<h3><a class="header" href="#signing-a-verifiable-presentation" id="signing-a-verifiable-presentation">Signing a Verifiable Presentation</a></h3>
<p>Once you've crafted your Verifiable Presentation and added your Verifiable Credentials to it, it is time to sign it.
This can be achieved with the <code>sign</code> method. It requires a <code>keyDoc</code> parameter (an object with the params and keys you'll use for signing), and a <code>challenge</code> string for the proof. It also accepts a <code>domain</code> string for the proof, a <code>resolver</code> in case you're using DIDs and a boolean <code>compactProof</code> that determines whether you want to compact the JSON-LD or not:</p>
<pre><code class="language-javascript">&gt;   await vp.sign(
          keyDoc,
          'some_challenge',
          'some_domain',
        );
</code></pre>
<p>Please note that signing is an async process.
Once done, your <code>vp</code> object will have a new <code>proof</code> field:</p>
<pre><code class="language-javascript">&gt;   vp.proof
&lt;-  {
      &quot;type&quot;: &quot;EcdsaSecp256k1Signature2019&quot;,
      &quot;created&quot;: &quot;2020-04-14T20:57:01Z&quot;,
      &quot;challenge&quot;: &quot;some_challenge&quot;,
      &quot;domain&quot;: &quot;some_domain&quot;,
      &quot;jws&quot;: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEUCIQCTTpivdcTKFDNdmzqe3l0nV6UjXgv0XvzCge--CTAV6wIgWfLqn_62U8jHkNSujrHFRmJ_ULj19b5rsNtjum09vbg&quot;,
      &quot;proofPurpose&quot;: &quot;authentication&quot;,
      &quot;verificationMethod&quot;: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
    }
</code></pre>
<h3><a class="header" href="#verifying-a-verifiable-presentation" id="verifying-a-verifiable-presentation">Verifying a Verifiable Presentation</a></h3>
<p>Once your Verifiable Presentation has been signed you can proceed to verify it with the <code>verify</code> method.
If you've used DIDs you need to pass a <code>resolver</code> for them. You can also use the booleans <code>compactProof</code> (to compact the JSON-LD) and <code>forceRevocationCheck</code> (to force revocation check). Please beware that setting <code>forceRevocationCheck</code> to false can allow false positives when verifying revocable credentials.
If your credential has uses the <code>status</code> field, you can pass a <code>revocationAPI</code> param that accepts an object describing the API to use for the revocation check.
For the simplest cases you only need a <code>challenge</code> string and possibly a <code>domain</code> string:</p>
<pre><code class="language-javascript">&gt;   const results = await vp.verify('some_challenge', 'some_domain');
&gt;   results
&lt;-  {
      &quot;presentationResult&quot;: {
        &quot;verified&quot;: true,
        &quot;results&quot;: [
          {
            &quot;proof&quot;: {
              &quot;@context&quot;: &quot;https://w3id.org/security/v2&quot;,
              &quot;type&quot;: &quot;EcdsaSecp256k1Signature2019&quot;,
              &quot;created&quot;: &quot;2020-04-14T20:57:01Z&quot;,
              &quot;challenge&quot;: &quot;some_challenge&quot;,
              &quot;domain&quot;: &quot;some_domain&quot;,
              &quot;jws&quot;: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEUCIQCTTpivdcTKFDNdmzqe3l0nV6UjXgv0XvzCge--CTAV6wIgWfLqn_62U8jHkNSujrHFRmJ_ULj19b5rsNtjum09vbg&quot;,
              &quot;proofPurpose&quot;: &quot;authentication&quot;,
              &quot;verificationMethod&quot;: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
            },
            &quot;verified&quot;: true
          }
        ]
      },
      &quot;verified&quot;: true,
      &quot;credentialResults&quot;: [
        {
          &quot;verified&quot;: true,
          &quot;results&quot;: [
            {
              &quot;proof&quot;: {
                &quot;@context&quot;: &quot;https://w3id.org/security/v2&quot;,
                &quot;type&quot;: &quot;EcdsaSecp256k1Signature2019&quot;,
                &quot;created&quot;: &quot;2020-04-14T20:49:00Z&quot;,
                &quot;jws&quot;: &quot;eyJhbGciOiJFUzI1NksiLCJiNjQiOmZhbHNlLCJjcml0IjpbImI2NCJdfQ..MEUCIQCCCRuJbSUPePpOfkxsMJeQAqpydOFYWsA4cGiQRAR_QQIgehRZh8XE24hV0TPl5bMS6sNeKtC5rwZGfmflfY0eS-Y&quot;,
                &quot;proofPurpose&quot;: &quot;assertionMethod&quot;,
                &quot;verificationMethod&quot;: &quot;https://gist.githubusercontent.com/faustow/13f43164c571cf839044b60661173935/raw&quot;
              },
              &quot;verified&quot;: true
            }
          ]
        }
      ]
    }
</code></pre>
<p>Please note that the verification is an async process that returns an object when the promise resolves. This object contains separate results for the verification processes of the included Verifiable Credentials and the overall Verifiable Presentation. A boolean value for the entire verification process can be checked at the root level <code>verified</code> property.</p>
<h2><a class="header" href="#using-dids" id="using-dids">Using DIDs</a></h2>
<p>The examples shown above use different kinds of URIs as <code>id</code> property of different sections. It is worth mentioning that the use of DIDs is not only supported but also encouraged.
Their usage is very simple: create as many DIDs as you need and then use them instead of the URIs shown above.
For example when adding a subject to a Verifiable Credential here we're using a DID instead of a regular URI in the <code>id</code> property of the object:<code>vc.addSubject({ id: 'did:dock:123qwe123qwe123qwe', alumniOf: 'Example University' })</code>.
If you don't know how to create a DID there's a specific <a href="tutorial_did.html">tutorial on DIDs</a> you can read.
Bear in mind that you will need to provide a <code>resolver</code> method if you decide to use DIDs in your Verifiable Credentials or Verifiable Presentations. More on resolvers can be found in the <a href="tutorial_resolver.html">tutorial on Resolvers</a>.</p>
<p>Here's an example of issuing a Verifiable Credential using DIDs, provided that you've created and a DID that you store in <code>issuerDID</code>:</p>
<pre><code class="language-javascript">const issuerKey = getKeyDoc(issuerDID, dock.keyring.addFromUri(issuerSeed, null, 'ed25519'), 'Ed25519VerificationKey2018');
await vc.sign(issuerKey);
const verificationResult = await signedCredential.verify(resolver, true, true, { dock });
console.log(verificationResult.verified); // Should print `true`
</code></pre>
<h2><a class="header" href="#creating-a-keydoc" id="creating-a-keydoc">Creating a keyDoc</a></h2>
<p>It can be seen from the above examples that signing of credentials and presentations require keypairs to be formatted into a <code>keyDoc</code> object.
There is a helper function to help with this formatting, it's called <code>getKeyDoc</code> and it is located in the <code>vc</code> helpers.
Its usage is very simple, it accepts a <code>did</code> string which is a DID in fully qualified form, a <code>keypair</code> object (generated by either using polkadot-js's keyring for Sr25519 and Ed25519 or keypair generated with <code>generateEcdsaSecp256k1Keypair</code> for curve secp256k1)
and a <code>type</code> string containing the type of the provided key (one of the supported 'Sr25519VerificationKey2020', 'Ed25519VerificationKey2018' or 'EcdsaSecp256k1VerificationKey2019'):</p>
<pre><code class="language-javascript">  const keyDoc = getKeyDoc(did, keypair, type)
</code></pre>
<p>Please check the example on the <a href="tutorial_ipv.html#using-dids">previous section</a> or refer to the <a href="../../tests/integration/presenting.test.js">presenting integration tests</a> for a live example.</p>
<h1><a class="header" href="#revocation-1" id="revocation-1">Revocation</a></h1>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>Credential revocation is managed with on-chain revocation registries. To revoke a credential, its id (or hash of its id) must be
added to the credential. It is advised to have one revocation registry per credential type. Each registry has a unique id and
an associated policy. The policy determines who can update the revocation registry. The registry also has an &quot;add-only&quot; flag specifying
whether an id once added to the registry can be removed (leading to undoing the revocation) or not.
Similar to the replay protection mechanism for DIDs, for each registry, the last modified block number is kept which is updated
each time a credential is revoked or unrevoked.
For now, only one policy is supported which is that each registry is owned by a single DID. Also, neither the policy
nor the &quot;add-only&quot; flag can be updated post the creation of the registry for now.</p>
<h2><a class="header" href="#registry-creation" id="registry-creation">Registry creation</a></h2>
<p>To create a registry, first a <code>Policy</code> object needs to be created for which a DID is needed. It is advised that the DID
is registered on chain first (else someone can look at the registry a register the DID, thus controlling the registry).</p>
<pre><code class="language-js">import {OneOfPolicy} from '@dock/sdk/utils/revocation';
const policy = new OneOfPolicy();
policy.addOwner(ownerDID);

// Or in a single step
const policy = new OneOfPolicy([ownerDID]);
</code></pre>
<p>Now create a random registry id. The registry id supposed to be unique among all registries on chain.</p>
<pre><code class="language-js">import {createRandomRegistryId} from '@dock/sdk/utils/revocation';
const registryId = createRandomRegistryId();
</code></pre>
<p>Now send the transaction to create a registry on-chain using <code>dock.revocation.newRegistry</code>. This method accepts the registry id,
the policy object and a boolean that specifies whether the registry is add-only or not meaning that whether undoing revocations
is allowed or not. Ifs <code>true</code>, it makes the registry add-only meaning that undoing revocations is not allowed, if <code>false</code>,
undoing is allowed.</p>
<pre><code class="language-js">// Setting the last argument to false to allow unrevoking the credential (undoing revocation)
const transaction = dock.revocation.newRegistry(registryId, policy, false);
await dock.sendTransaction(transaction);
</code></pre>
<h2><a class="header" href="#revoking-a-credential" id="revoking-a-credential">Revoking a credential</a></h2>
<p>Revoking a credential requires a signature from the owner of the registry. For that, fetch the owner's DID and pair and
create a map</p>
<pre><code class="language-js">const didKeys = new KeyringPairDidKeys();
didKeys.set(ownerDID, ownerKeypair);
</code></pre>
<p>Now get the registry id, <code>registryId</code> and the revocation id (the hash of credential id), <code>revokeId</code> and send the transaction on chain.
Revoking an already revoked credential has no effect.</p>
<pre><code class="language-js">const transaction = await dock.revocation.revokeCredential(didKeys, registryId, revokeId);
await dock.sendTransaction(transaction);
</code></pre>
<p>Revoking multiple ids in a single transaction is possible but with a lower level method <code>dock.revocation.revoke</code>.</p>
<h2><a class="header" href="#undoing-a-revocation" id="undoing-a-revocation">Undoing a revocation</a></h2>
<p>Similar to revocation, undoing the revocation also requires a signature from the owner of the registry. As before, fetch
the owner's DID and pair and create a map</p>
<pre><code class="language-js">const didKeys = new KeyringPairDidKeys();
didKeys.set(ownerDID, ownerKeypair);
</code></pre>
<p>Now get the registry id, <code>registryId</code> and the revocation id to undo, <code>revokeId</code> and send the transaction on chain.
Unrevoking an unrevoked credential has no effect.</p>
<pre><code class="language-js">const transaction = await dock.revocation.unrevokeCredential(didKeys, registryId, revokeId);
await dock.sendTransaction(transaction);
</code></pre>
<p>Undoing revocation for multiple ids in a single transaction is possible but with a lower level method <code>dock.revocation.unrevoke</code>.</p>
<h2><a class="header" href="#checking-the-revocation-status" id="checking-the-revocation-status">Checking the revocation status</a></h2>
<p>To check an id is revoked or not, call <code>dock.revocation.getIsRevoked</code> with the registry id and revocation id. Returns <code>true</code>
if revoked else <code>false</code>.</p>
<pre><code class="language-js">const isRevoked = await dock.revocation.getIsRevoked(registryId, revokeId);
</code></pre>
<h2><a class="header" href="#fetching-the-registry-details" id="fetching-the-registry-details">Fetching the registry details</a></h2>
<p>To get the details of the registry like policy, add-only status and block number when it was last updated, use <code>dock.revocation.getRegistryDetail</code></p>
<h2><a class="header" href="#removing-the-registry" id="removing-the-registry">Removing the registry</a></h2>
<p>A registry can be deleted leading to all the corresponding revocation ids being deleted as well. This requires the signature
from owner like other updates. Use the <code>dock.revocation.removeRegistry</code> method to remove a registry.</p>
<pre><code class="language-js">const lastModified = await dock.revocation.getBlockNoForLastChangeToRegistry(registryId);
const transaction = dock.revocation.removeRegistry(registryId, lastModified, didKeys);
await dock.sendTransaction(transaction);
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
